package chapter10note;

public class note1 {
    /*
    10.1类变量与类方法
    类方法中不能使用和对象有关的关键字：比如this和super。
    静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员。
     */
    /*
    10.2理解main方法语法
     */
    /*
    10.3代码块
    1、基本介绍
    代码块又称为初始化块，属于类中的成员【是类的一部分】，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。
    但和方法不同，没有方法名、返回、参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时的隐式调用。
    2、基本语法
    【修饰符】{代码}; 1、修饰符可选，要写的话只能写static；
                    2、代码分为：静态代码块（使用static修饰，随着类的加载而执行，并且只会执行一次）、普通代码块/非静态代码块（创建一次对象调用一次）；
                    3、;可以省略。
     3、代码块的好处
     类加载：1、创建对象实例时；
            2、创建子类对象实例，父类也会被加载；
            3、使用类的静态成员时（静态属性，精态方法）
     创建一个对象时，在一个类调用顺序是：1、调用静态代码块和静态属性初始化
                                2、调用普通代码块和普通属性的初始化
                                3、调用构造方法
     构造器的最前面起始隐含了super（）和调用普通代码块。
     创建子类对象时，调用顺序：1、父类的静态代码块和静态属性；
                            2、子类的静态代码块和静态属性；
                            3、父类的普通代码块和普通属性初始化；
                            4、父类的构造方法
                            5、子类的普通代码块和普通属性初始化
     静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员。
     */
    /*
     10.4单例设计模式
     1、两种方式：1、饿汉式：private static 类名 对象名 = new 类名（""）； private 类名（）{}
            2、懒汉式：private static 类名 对象名;//默认为null private 类名(){}; private static 类名 getInstace(){if(null)对象名 = new 类名（“”）}
     2、实现步骤：1、构造器私用化；
            2、类的内部创建对象；
            3、向外暴露一个静态的公共的方法。
     3、区别：1、创建时机不同（饿汉式：类加载；懒汉式：使用时）；
            2、饿汉式不存在线程安全问题，懒汉式存在线程安全问题；
            3、饿汉式存在资源浪费的可能。
     */
    /*
     10.5final关键字
    1、基本介绍：final可以修饰类、属性、方法和局部变量
            使用情况：1、不希望父类被继承时； final class A{}
                    2、不希望父类的某个方法被子类覆盖、重写； public final void hi(){}
                    3、不希望类的某个属性的值被修改； public final double TAX_RATE = 0.08;
                    4、不希望某个局部变量被修改。final double TAX_RATE = 0.08;
     2、使用注意事项：1、final修饰的属性又叫常量，一般用XX_XX来命名；
                2、final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值位置：定义、构造器、代码块；
                3、若final修饰的属性是静态的，则初始化的位置只能是：定义、静态代码块；
                4、final类不能继承，但是可以实例化对象；
                5、若类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。
                6、若一个类已经是final类了，就没有必要再将方法修饰成final方法；
                7、final不能修饰构造方法（即构造器）
                8、final和static往往搭配使用，效率更高，不会导致类加载
                8、包装类都是final类
     */
    /*
     10.6抽象类
     1、当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类。
     2、介绍：1、用abstract关键字来修饰一个类时，这个类就叫抽象类 访问修饰符 abstract 类名{}
            2、  。。。。。。。。。。。方法。。。。。。。。方法 访问修饰符 abstract 返回类型 方法名（参数列表）；//没有方法体{}
     3、注意事项：1、抽象类不能被实例化；
            2、抽象类不一定包含abstract方法；
            3、一旦类包含了abstract方法，则这个类必须声明为abstract；
            4、abstract只能修饰类和方法，不能修饰属性和其他的；
            5、抽象类可以有任意成员【抽象类本质还是类】；
            6、抽象方法不能有主体，即不能实现；
            7、如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类；
            8、抽象方法不能用private、final、static来修饰，因为这些关键字都是和重写相违背的。
     */
    /*
    10.7抽象类最佳实践——模板设计模式
    1、解决的问题：1、当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类实现
                2、编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给子类实现，就是一种模板模式
                3、System.currentTimeMills():记录当前时间
     */
    /*
    10.8接口
    1、基本介绍：1、接口就是给出一些没有时间的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。
                2、语法： interface 接口名{//属性//抽象方法}
                        class 类名 implements 接口{自己属性；自己方法；必须实现的接口的抽象方法}
                3、接口是更加抽象的抽象类，抽象类里可以有方法体，接口里的所有方法都没有方法体。接口体现了程序设计的多态和高内聚低耦合的设计思想。
     2、注意事项和细节：1、接口不能被实例化
                    2、接口中的所有方法是public方法，接口中抽象方法，可以不用abstract修饰
                    3、一个普通类实现接口，就必须将该接口的所有方法都实现
                    4、抽象类实现接口，就可以不用实现接口的方法
                    5、一个类同时可以实现多个接口
                    6、接口中的属性，只能是final的，而且是public static final修饰符
                    7、接口中属性的访问形式：接口名.属性名
                    8、接口不能继承其它的类，但是可以继承多个别的接口：interface A extends B,C{}
                    9、接口的修饰符只能是public和默认，这点和类的修饰符是一样的
     3、接口vs继承类：1、解决问题不同:继承：代码的复用性和可维护性
                                接口：设计，设计好各种规范（方法），让其他类去实现这些方法，更加灵活
                    2、接口在一定程度上实现代码解耦
     4、接口的多态特性：1、多态参数：类（class _ implements  ）
                    2、多态数组：类（class _ implements  ）
     */
    /*
    10.9内部类
    如果定义类在局部位置（方法中/代码块）：局部内部类、匿名内部类
    定义在成员位置：成员内部类、静态内部类
     */
}
